{"mode":"editor","version":1,"windowDimensions":{"x":65,"y":24,"width":1301,"height":744,"maximized":true},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/home/iraasta/Dropbox/Elixir/typed"],"buffers":[{"text":"defmodule Typed.Mixfile do\n  use Mix.Project\n\n  def project do\n    [app: :typed,\n     version: \"0.0.1\",\n     elixir: \"~> 1.0\",\n     build_embedded: Mix.env == :prod,\n     start_permanent: Mix.env == :prod,\n     deps: deps]\n  end\n\n  # Configuration for the OTP application\n  #\n  # Type `mix help compile.app` for more information\n  def application do\n    [applications: [:logger]]\n  end\n\n  # Dependencies can be Hex packages:\n  #\n  #   {:mydep, \"~> 0.3.0\"}\n  #\n  # Or git/path repositories:\n  #\n  #   {:mydep, git: \"https://github.com/elixir-lang/mydep.git\", tag: \"0.1.0\"}\n  #\n  # Type `mix help deps` for more examples and options\n  defp deps do\n    []\n  end\nend\n","markerStore":{"nextMarkerId":1,"markersById":{"0":{"range":{"start":{"row":11,"column":0},"end":{"row":11,"column":0}},"properties":{"type":"selection","editorId":4,"preserveFolds":true,"goalScreenRange":null},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":2,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/iraasta/Dropbox/Elixir/typed/mix.exs","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"8ce6266f64d458ab60b8b301a57de09685e60552","deserializer":"TextBuffer","version":2},{"text":"defmodule Typed do\n\n  defmacro __using__(_) do\n    quote do\n      import Kernel, except: [def: 2]\n      import Typed\n    end\n  end\n\n  defmacro def(fun_def, opts) do\n    quote do\n      IO.puts \"Defining #{inspect unquote(Macro.escape(fun_def))}\"\n      IO.puts \"Defining #{inspect unquote(Macro.escape(opts))}\"\n\n      Kernel.def unquote(fun_def) do\n        IO.puts \"Calling #{inspect unquote(Macro.escape(fun_def))}\"\n        IO.puts \"Calling #{inspect unquote(Macro.escape(opts))}\"\n        unquote(opts[:do])\n      end\n    end\n  end\n\n  # defmacro {var, meta, args} :: {type, _, _} do\n  #   {var, [{:type, type}|meta], args}\n  # end\n\n  # defmacro a :: b do\n  #   raise TypedError, message: \"Wrong type annotation: #{inspect b}\\n For var: #{inspect a}\"\n  # end\n\n  def prewalk(ast, acc \\\\ %{}) do\n    Macro.prewalk ast, acc, fn e, acc ->\n      expand(e, __ENV__, acc)\n    end\n  end\n\n  # Inside binaries\n  def expand {:<<>>, m, args}, _, acc do\n    newargs = Macro.prewalk args, fn\n      {n, meta, args} -> {n, [{:inside_binary, true} | meta], args}\n      e -> e\n    end\n    {{:<<>>, m, newargs}, acc}\n  end\n\n  # Right type annotations\n  def expand {:::, _, [{var, meta, args}, {type, _, _}]} = whole, _, acc do\n    case inside_binary meta do\n      true -> {whole, acc}\n      _    ->\n        {{var, [{:type, type}|meta], args}, Map.put(acc,var,{:type, type})}\n    end\n  end\n\n  # Wrong type annotations\n  def expand {:::, meta, [a,b]} = whole, _, acc do\n    case inside_binary meta do\n      true -> {whole, acc}\n      _    -> raise TypedError, message: \"Wrong type annotation: #{inspect b}\\n For var: #{inspect a}\"\n    end\n  end\n\n  #Asignments\n  def expand {:=, _m, [{lname, _, _}, {rname, _, _}]} = whole, _, acc do\n    type = Map.get(acc,rname)\n    {whole , Map.put(acc, lname, type)}\n  end\n\n  # Tuple triplets\n  def expand({_, _meta, _} = whole, bindings, acc) do\n    {Macro.expand(whole, bindings), acc}\n  end\n\n  # Bare values\n  def expand(e, bindings, acc), do: {Macro.expand(e, bindings), acc}\n\n  def inside_binary(meta) do\n    Keyword.has_key?(meta, :inside_binary)\n  end\n\n  # Get vars helper\n  def get_vars(ast) do\n    Macro.prewalk ast, [], fn\n      {_, _, atom} = whole, acc when is_atom(atom)  ->\n        {whole, [whole | acc]}\n      e, acc ->\n        {e, acc}\n    end\n  end\nend\n\ndefmodule TypedError do\n  defexception message: \"Wrong type annotation\"\nend\n","markerStore":{"nextMarkerId":1,"markersById":{"0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","editorId":8,"preserveFolds":true,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":2,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/iraasta/Dropbox/Elixir/typed/lib/typed.ex","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"02c7c072a5f0b86eebbed3066a98f5d5ad801b5a","deserializer":"TextBuffer","version":2},{"text":"defmodule Typed.Typespecs do\n  # Get specs with types replaced\n  def get_true_spec (module) do\n    map = get_type_map(module)\n    Kernel.Typespec.beam_specs(module)\n    |> Enum.map fn {_name, types} -> replace_type(types, map) end\n  end\n\n  # Replace remote types in specs\n  def replace_type [{:remote_type, _, _} = t | r ], tm do\n    IO.inspect(t)\n    IO.puts \"REPLACING\"\n    [t | replace_type(r,tm)]\n  end\n  def replace_type [{type, line, name, args} | types], typesMap do\n    case typesMap[name] do\n        nil   -> [{type, line, name, replace_type(args,typesMap)} | replace_type(types,typesMap)]\n        type  -> [type | replace_type(types,typesMap)]\n    end\n  end\n  def replace_type([type | types], typesMap), do: [type | replace_type(types, typesMap)]\n  def replace_type([], _), do: []\n  #def replace_type(any, _), do: any\n\n  # Get map of type aliases\n  def get_type_map(module) do\n    (Kernel.Typespec.beam_types(module) || [])\n    |> Enum.reduce %{}, fn ({_, {name, type, _arg}},b) -> Map.put(b, name, type) end\n  end\n\n\nend\n","markerStore":{"nextMarkerId":32,"markersById":{"0":{"range":{"start":{"row":26,"column":46},"end":{"row":26,"column":46}},"properties":{"type":"selection","editorId":169,"goalScreenRange":null,"autoscroll":true,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true},"24":{"range":{"start":{"row":26,"column":45},"end":{"row":26,"column":46}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"25":{"range":{"start":{"row":26,"column":4},"end":{"row":26,"column":5}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"26":{"range":{"start":{"row":26,"column":45},"end":{"row":26,"column":46}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"27":{"range":{"start":{"row":26,"column":4},"end":{"row":26,"column":5}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"28":{"range":{"start":{"row":26,"column":45},"end":{"row":26,"column":46}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"29":{"range":{"start":{"row":26,"column":4},"end":{"row":26,"column":5}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"30":{"range":{"start":{"row":26,"column":45},"end":{"row":26,"column":46}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"31":{"range":{"start":{"row":26,"column":4},"end":{"row":26,"column":5}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":30,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/iraasta/Dropbox/Elixir/typed/lib/typespecs.ex","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7522b6df71f7e8beb83ab264549f0551fb7df011","deserializer":"TextBuffer","version":2},{"text":"defmodule Typed.Comparator do\n\n\n  @y fn f ->\n    fun = fn x ->\n      f.(fn y,z -> (x.(x)).(y,z) end)\n    end\n    fun.(fun)\n  end\n\n  @types [\n    {:any,                    quote unquote: false do (fn a -> a != nil        end) end, [\n      {:number,               quote unquote: false do(fn a -> is_number(a)    end) end, [\n        {:integer,            quote unquote: false do(fn a -> is_integer(a)   end) end, [\n          {:non_neg_integer,  quote unquote: false do(fn a -> a >= 0          end) end, []},\n          {:neg_int,          quote unquote: false do(fn a -> a < 0           end) end, []}\n        ]},\n        {:float,              quote unquote: false do(fn a -> is_float(a)     end) end, []}\n      ]},\n      {:atom,                 quote unquote: false do(fn a -> is_atom(a)      end) end, []},\n      {:tuple,                quote unquote: false do(fn a -> is_tuple(a)     end) end, []},\n      {:list,                 quote unquote: false do(fn a -> is_list(a)      end) end, []}\n    ]},\n    {:none,                   quote unquote: false do(fn a -> a == nil        end) end, []}\n  ]\n\n  @y.(fn map_types ->\n    fn types, parents ->\n      Enum.each types, fn {type, _f, children} ->\n        def compare_types(unquote(type), t) do\n          t == unquote(type) || (t in unquote(parents))\n        end\n        map_types.(children, [type | parents])\n      end\n    end\n  end).(@types, [])\n\n  def compare_types(x,y) when is_tuple(x) and is_tuple(y) do\n    compare_types(Tuple.to_list(x), Tuple.to_list(y))\n  end\n  def compare_types(x,y) when is_list(x) and is_list(y) do\n    Enum.zip(x,y)\n    |> Enum.reduce true, fn {t1,t2}, acc -> compare_types(t1,t2) && acc end\n  end\n  def compare_types(x,:list) when is_list(x),   do: true\n  def compare_types(x,:tuple) when is_tuple(x), do: true\n  def compare_types([],[]), do: true\n\n  def compare_types(_,_), do: false\n\n\n  def get_type(x) when is_tuple(x) do\n    Tuple.to_list(x)\n    |> get_type()\n    |> List.to_tuple()\n  end\n  def get_type([x|t]) do\n    [get_type(x) | get_type(t)]\n  end\n  def get_type([]), do: []\n  def get_type(x) do\n    is_type(x, @types)\n  end\n\n\n\n  def is_type(x, [{type, check, children} | t]) do\n    {test, _} = Code.eval_quoted(check)\n    if test.(x) do\n      case children do\n        [] -> type\n        _  -> is_type(x, children)\n      end\n    else is_type(x, t) end\n  end\n  def is_type(_, []), do: raise NoSuchType\nend\ndefmodule NoSuchType do\n  defexception message: \"Not implemented type\"\nend\n","markerStore":{"nextMarkerId":74,"markersById":{"0":{"range":{"start":{"row":39,"column":5},"end":{"row":39,"column":5}},"properties":{"type":"selection","editorId":91,"goalScreenRange":null,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":56,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/iraasta/Dropbox/Elixir/typed/lib/comparator.ex","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7159c6cbb6b93452d16768c0c8191dfda6bd45c0","deserializer":"TextBuffer","version":2},{"text":"defmodule AnnotationTest do\n  use ExUnit.Case\n  use Typed\n\n  # test \"Doesn't ruin anything\" do\n  #   #1\n  #   (a :: int) = 1\n  #   assert a == 1\n  #\n  #   #2\n  #   {a :: atom, b :: int} = {1,2}\n  #   assert {^a, ^b} = {1,2}\n  # end\n  #\n  # test \"Doesn't ruin the binaries\" do\n  #   #1\n  #   assert <<256 :: size(16)>> = <<1, 0>>\n  #\n  #   #2\n  #   assert <<256 :: utf8>> = \"Ā\"\n  # end\n\n  test \"Throws type exceptions\" do\n    q = quote do 1 :: 2 end\n    assert_raise TypedError, fn -> Typed.prewalk q end\n  end\n\n  test \"Is identical except for the type\" do\n    #1\n    q1 = quote do: a :: int\n    q2 = quote do: a\n    {{:a, ctxt, args}, _} = Typed.expand  q1, __ENV__, %{}\n    oldctxt = Keyword.delete_first(ctxt, :type)\n    assert {:a, oldctxt, args} == q2\n  end\n\n\n  test \"Prewalks - doesn't throw\" do\n    test1 = quote do\n      <<256 :: utf8>>\n    end\n    {test,_} = Typed.prewalk(test1)\n    assert {\"Ā\", []} == Code.eval_quoted(test,[], __ENV__)\n  end\n\n  test \"Prewalks - Doesn't fuck up binaries\" do\n    test2 = quote do\n      <<0, 1, x :: binary>> = <<0, 1, 2, 3>>\n    end\n    {test,_} = Typed.prewalk(test2)\n    assert {<< 0, 1, 2, 3 >>, _} = Code.eval_quoted test, [], __ENV__\n  end\n\n  test \"Prewalks - assign simple types\" do\n    test1 = quote do\n      (b :: int) = 10\n    end\n    {_, bindings} = Typed.prewalk test1\n    assert {:type, :int} = Map.get(bindings , :b)\n  end\n\n  test \"Prewalks - assign derivative types\" do\n    test = quote do\n      (b :: int ) = 10\n      a = b\n    end\n    {_, bindings} = Typed.prewalk test\n    assert {:type, :int} = Map.get bindings, :a\n    assert {:type, :int} = Map.get bindings, :b\n  end\n\n  #TODO Finish\n  # test \"Prewalks - assign infered types\" do\n  #   test = quote do\n  #     b = 10\n  #   end\n  #   {q, bindings} = Typed.prewalk test\n  #   assert {:type, :int} = Map.get bindings, :b\n  # end\n\n  test \"Prewalks - assing spec types\" do\n\n  end\n\n  test \"Prewalks - assign compound types\" do\n\n  end\n\n  test \"Prewalks - assign function return types\" do\n\n  end\n\n\nend\n","markerStore":{"nextMarkerId":1,"markersById":{"0":{"range":{"start":{"row":75,"column":9},"end":{"row":75,"column":9}},"properties":{"type":"selection","editorId":157,"goalScreenRange":null,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":2,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/iraasta/Dropbox/Elixir/typed/test/annotation_test.exs","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"4d02379507d0eca9d869f0d4b0445fb7dde6d663","deserializer":"TextBuffer","version":2},{"text":"defmodule ComparatorTest do\n  use ExUnit.Case\n  alias Typed.Comparator\n\n\n\n  test \"Compare simple polymorphic types\" do\n    assert Comparator.compare_types :integer,             :any\n    refute Comparator.compare_types :any,                 :integer\n    assert Comparator.compare_types :non_neg_integer,     :integer\n    refute Comparator.compare_types :integer,             :non_neg_integer\n    assert Comparator.compare_types :float,               :number\n  end\n\n  test \"get_type\" do\n    assert :non_neg_integer == Comparator.get_type(1)\n    assert Comparator.get_type(1.0) == :float\n    assert Comparator.get_type({1,:atom}) == {:non_neg_integer, :atom}\n  end\n\n  @doc \"\"\"\n    Commented out previous format\n    New format is:\n    {type, line_number, [arguments]}\n    instead of\n    :type\n  \"\"\"\n  test \"Compare compund polymorphic types\" do\n    # assert Comparator.compare_types [:integer],[:any]\n\n    # assert Comparator.compare_types {:integer, :any},{:any, :any}\n    # refute Comparator.compare_types {:integer, :any},{:float, :any}\n    # assert Comparator.compare_types {:int, :string},       :tuple\n    # refute Comparator.compare_types {:int, :string},       {:int, :int}\n    # assert Comparator.compare_types [1,2,3],       :list\n    # assert Comparator.compare_types 1,       :non_neg_integer\n  end\n\nend\n","markerStore":{"nextMarkerId":348,"markersById":{"0":{"range":{"start":{"row":11,"column":0},"end":{"row":11,"column":0}},"properties":{"type":"selection","editorId":110,"goalScreenRange":null,"clip":"forward","preserveFolds":true},"reversed":true,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true},"15":{"range":{"start":{"row":34,"column":38},"end":{"row":34,"column":45}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"155":{"range":{"start":{"row":23,"column":4},"end":{"row":23,"column":35}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"265":{"range":{"start":{"row":23,"column":24},"end":{"row":23,"column":34}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"321":{"range":{"start":{"row":25,"column":4},"end":{"row":25,"column":9}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true},"330":{"range":{"start":{"row":36,"column":0},"end":{"row":36,"column":5}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":602,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/iraasta/Dropbox/Elixir/typed/test/comparator_test.exs","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"03764fc0a89214b14ee1a6877dc1acf7d189dfcc","deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":4,"softTabs":true,"displayBuffer":{"id":5,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/home/iraasta/Dropbox/Elixir/typed/mix.exs","deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":8,"softTabs":true,"displayBuffer":{"id":9,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/home/iraasta/Dropbox/Elixir/typed/lib/typed.ex","deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":169,"softTabs":true,"displayBuffer":{"id":170,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/home/iraasta/Dropbox/Elixir/typed/lib/typespecs.ex","deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":91,"softTabs":true,"displayBuffer":{"id":92,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/home/iraasta/Dropbox/Elixir/typed/lib/comparator.ex","deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":157,"softTabs":true,"displayBuffer":{"id":158,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/home/iraasta/Dropbox/Elixir/typed/test/annotation_test.exs","deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":110,"softTabs":true,"displayBuffer":{"id":111,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/home/iraasta/Dropbox/Elixir/typed/test/comparator_test.exs","deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/home/iraasta/Dropbox/Elixir/typed/mix.exs","focused":true,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-elixir","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":"","modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false,"wholeWord":false},"projectViewState":"","resultsModelState":{"useRegex":false,"caseSensitive":false},"findHistory":["replaceType","expand","Typed","@cb.(fn a ->","a","cb","end)"],"replaceHistory":["replace_type","Comparator","check do:","var!(a)","quote unquote: false do","end) end"],"pathsHistory":["replace_type","Comparator","check do:","var!(a)","quote unquote: false do","end) end"]},"fuzzy-finder":{"/home/iraasta/Dropbox/Elixir/typed/mix.exs":1437468823167,"/home/iraasta/Dropbox/Elixir/typed/lib/typed.ex":1435681400222,"/home/iraasta/Dropbox/Elixir/typed/lib/typespecs.ex":1435681396951,"/home/iraasta/Dropbox/Elixir/typed/lib/comparator.ex":1435681409535,"/home/iraasta/Dropbox/Elixir/typed/test/annotation_test.exs":1435684147433,"/home/iraasta/Dropbox/Elixir/typed/test/comparator_test.exs":1437468774913},"metrics":{"sessionLength":100172},"tree-view":{"directoryExpansionStates":{"/home/iraasta/Dropbox/Elixir/typed":{"isExpanded":true,"entries":{"_build":{"isExpanded":false,"entries":{}},"config":{"isExpanded":true,"entries":{}},"cover":{"isExpanded":true,"entries":{}},"lib":{"isExpanded":true,"entries":{}},"test":{"isExpanded":true,"entries":{}}}}},"selectedPath":"/home/iraasta/Dropbox/Elixir/typed/mix.exs","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":242},"keybinding-resolver":{},"term2":{"termViews":[""]},"tabs":[{}]}}